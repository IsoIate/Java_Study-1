# 2장 자바와 절차적/구조적 프로그래밍

### 1. 자바의 T 메모리
  자바 프로그램이 메모리를 사용하는 방식은 코드 실행 영역과 데이터 저장 영역이 있다.
  그 중 데이터 저장 영역은 3가지로 나뉜다.
  1. 스태틱(Static) 영역
   - 클래스들의 놀이터
   - 프로그램 실행 시 JVM이 개발자가 작성한 __모든 클래스와 임포트 패키지__ 를 스태틱 영역에 가져다 놓음
   - java.lang 패키지는 필수로 들어감 (System.out.println() 같은 메서드를 쓸 수 있는 이유)
   - 클래스의 전역변수는 스태틱 영역에서 관리
   
  2. 스택(Stack) 영역   
   - 메서드들의 놀이터   
   - main() 메서드 처럼 메서드들이 들어가고 메서드 매개변수 지역변수, if 스택 프레임, for 스택 프레임 등 기본적인 메서드, 변수들이 들어감   
   - 메서드들은 서로 스택프레임이 다르기 때문에 메서드들 끼리 변수 공유가 불가능   
   - 지역변수는 스택 프레임에 종속된 변수이고, 전역변수는 스택 프레임에 독립된 변수   
   - 프로젝트의 규모가 커질수록 전역변수의 값에 들어있는 데이터를 파악하기 힘드므로 될수있으면 사용을 자제하는게 맞음   
   - 읽기 전용으로 값을 공유하는 경우는 전역 상수로 쓰는 것을 추천 ex) Math.PI 등   
   - 스레드도 스택 영역에서 관리, 스레드의 개수만큼 분할해서 사용 (멀티 프로세스는 데이터 저장 영역에 다수의 T 메모리 만들어서 사용)   
   - 하나의 T 메모리의 스택 프레임을 분할해서 사용하는 멀티 쓰레드와 여러개의 T 메모리를 사용하는 멀티 프로세스를 비교하면 속도차이가 큼   
   (Servlet 은 요청당 프로세스가 아닌 요청당 스레드를 생성함... ~~분명 웹을 배웠는데 왜 처음듣는거같지~~  아무튼 그래서 요청당 쓰레드(Servlet)이 요청당 프로세스(CGI)보다 효율적임)   
    
  3. 힙(Heap) 영역
   - 객체들의 놀이터
   - 객체가 상주하는 구역... (2장에선 다루지 않음)
   - new 연산자를 사용하여 객체를 생성할 경우 힙영역에 인스턴스가 생성되고 오랜기간 사용하지 않을 경우 가비지 컬렉터가 메모리를 정리한다 
   
   __※ 추가사항__  
   ```
   static 변수    ------>    클래스(멤버) 속성, 정적 변수, 정적 속성....         ---------> 스태틱 영역  
   인스턴스 변수   ------>    객체(멤버) 속성, 객체 변수 ...                     ---------> 힙 영역  
   local 변수     ------>    지역 변수                                         ---------> 스택 영역(스택 프레임 내부)  
   ```
  
    
# 3장 자바와 객체 지향
### 객체지향은 인간 지향이다
  프로그래밍 언어의 발전사를 보면 개발자를 더욱 편하고 이롭게 하기 위한 과정임을 알 수 있다.
  
  포인터같이 눈높이를 기계 수준으로 낮추지 않으면 이해하기 매우 힘든 부분이라서 인간이 이해하기 쉽게 현실 세계처럼 프로그래밍하는 방법을 찾다가
  객체 향 개념이 탄생함
  
  기존의 구조적 프로그래밍 언어에서 가장 중요하게 여긴건 "함수"였다. 함수는 코드를 논리적인 단위로 구분하고 분할해서 정복하자라는 것이다.
  
  즉 D&C하자는 것이다. (D&C는 Divide and Conquer의 머리로 분할 정복이라는 뜻이다)
  
  아무리 복잡한 문제라도 작은 문제로 분할해서 하나씩 정복하다 보면 결국 해결된다는 전략
  몇 천, 몇 만 라인의 명령어를 논리적인 단위로 나누어 블록화해서 작성하자는 것이다. 이런 논리적인 단위의 블록을 함수라고 함
  
  함수의 목적 : 논리의 분할, 중복 제거
  
  함수로 인하여 프로그래밍이 좀 더 편해지고 나서 더욱 파격적인 제안이 나온 것이 바로 객체 지향 개념이다.
  
  ### 객체지향의 4대 특성 - 캡! 상추다
  - 캡 -> 캡슐화(Encapsulation) : 정보 은닉(information hiding)
  - 상 -> 상속 ~~(Inheritance)~~ : 재사용
    - 상속의 개념 -> 조직도, 계층도 (X), 분류도 (O)  
    - 상속관계에서 반드시 만족해야 할 문장  
        -__하위 클래스는 상위 클래스다.__  
    - __하위클래스의 인스턴스가 생성될 때 상위클래스의 인스턴스도 함께 생성된다.__  
  - 추 -> 추상화(Abstraction) : 모델링
    - 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용
    - 추상화는 모델링이다.
    - __구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것__
    - 클래스 설계에서 가장 중요한 것은 __추상화__
    - 추상화를 넓게 본다면 아래의 내용도 포함된다.
      1. 상속을 통한 추상화, 구체화
      2. 인터페이스를 통한 추상화
      3. 다형성을 통한 추상화
  - 다 -> 다형성(Polymorphism) : 사용 편의  
     - 상위 클래스와 하위 클래스 사이의 다형성  
     - 인터페이스와 구현클래스의 다형성  
     - 오버로딩과 오버라이딩  

# 4장 자바가 확장한 객체지향
 - static 블록 -> 스태틱 영역에 로딩될 때 실행이지만, 실제로는 해당 패키지 또는 클래스가 처음으로 사용될 때 로딩되는 것이 맞음  
 ```java
 class A {
     static {
          System.out.println("스태틱 블록");
     }
 }
 ```
 - 인스턴스 블록 -> 인스턴스가 생성될 때마다 블록 실행, 객체 생성자가 실행되기 전에 먼저 실행
 ```java
 class A {
     {
          System.out.println("인스턴스 블록");
     }
 }
 ```
 - instanceof -> 하위클래스와 상위클래스 관계는 true 반환  
 ```java
 하위클래스 instanceof 하위클래스
 하위클래스 instanceof 상위클래스
 ```
 - this -> 똑같은 인스턴스가 여러개 있을 때 힙 영역에서 한개의 인스턴스와 스태틱 영역에 정적 인스턴스를 하나 만들어서 this 키워드를 사용하여 업무 수행..  
 - 만약 아래와 같이 100개의 인스턴스를 생성한 후 test 메소드를 실행한다면 힙영역의 낭비
 ```java
 
 class A{
    void test(){
        System.out.println("테스트");
    }
 }
 ...
 A[] a = new A[100];
 for(int i=0;i<a.length;i++){
    a[i] = new A();
 }
 for(int i=0;i<a.length;i++){
     a[i].test();
 }
 ```
 
 ```java
    // 이렇게 변경되서 사용된다고 생각하면 됨
    class A{
    static void test(A this){
        System.out.println("테스트");
    }
    ...
    A[] a = new A[100];
 for(int i=0;i<a.length;i++){
    a[i] = new A();
 }
 for(int i=0;i<a.length;i++){
     A.test(a[i]);
 }
 }
 ```
 __※ 추후에 람다와 자바8 리플렉션, 스트림 API [일급 컬렉션](https://jojoldu.tistory.com/412?category=635881)__
 
 # 전체문서는 저작권 때문에 개인 드라이브로 이동
 - 개인 드라이브 : [스프링 입문을 위한 자바 객체지향의 원리와 이해](https://github.com/eggme/LSJ_Drive/blob/master/books/%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9E%85%EB%AC%B8%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EC%9E%90%EB%B0%94%20%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%EC%9D%98%20%EC%9B%90%EB%A6%AC%EC%99%80%20%EC%9D%B4%ED%95%B4.md)
