# 2장 자바와 절차적/구조적 프로그래밍

### 1. 자바의 T 메모리
  자바 프로그램이 메모리를 사용하는 방식은 코드 실행 영역과 데이터 저장 영역이 있다.
  그 중 데이터 저장 영역은 3가지로 나뉜다.
  1. 스태틱(Static) 영역
   - 클래스들의 놀이터
   - 프로그램 실행 시 JVM이 개발자가 작성한 __모든 클래스와 임포트 패키지__ 를 스태틱 영역에 가져다 놓음
   - java.lang 패키지는 필수로 들어감 (System.out.println() 같은 메서드를 쓸 수 있는 이유)
   - 클래스의 전역변수는 스태틱 영역에서 관리
   
  2. 스택(Stack) 영역   
   - 메서드들의 놀이터   
   - main() 메서드 처럼 메서드들이 들어가고 메서드 매개변수 지역변수, if 스택 프레임, for 스택 프레임 등 기본적인 메서드, 변수들이 들어감   
   - 메서드들은 서로 스택프레임이 다르기 때문에 메서드들 끼리 변수 공유가 불가능   
   - 지역변수는 스택 프레임에 종속된 변수이고, 전역변수는 스택 프레임에 독립된 변수   
   - 프로젝트의 규모가 커질수록 전역변수의 값에 들어있는 데이터를 파악하기 힘드므로 될수있으면 사용을 자제하는게 맞음   
   - 읽기 전용으로 값을 공유하는 경우는 전역 상수로 쓰는 것을 추천 ex) Math.PI 등   
   - 스레드도 스택 영역에서 관리, 스레드의 개수만큼 분할해서 사용 (멀티 프로세스는 데이터 저장 영역에 다수의 T 메모리 만들어서 사용)   
   - 하나의 T 메모리의 스택 프레임을 분할해서 사용하는 멀티 쓰레드와 여러개의 T 메모리를 사용하는 멀티 프로세스를 비교하면 속도차이가 큼   
   (Servlet 은 요청당 프로세스가 아닌 요청당 스레드를 생성함... ~~분명 웹을 배웠는데 왜 처음듣는거같지~~  아무튼 그래서 요청당 쓰레드(Servlet)이 요청당 프로세스(CGI)보다 효율적임)   
    
  3. 힙(Heap) 영역
   - 객체들의 놀이터
   - 객체가 상주하는 구역... (2장에선 다루지 않음)
   - new 연산자를 사용하여 객체를 생성할 경우 힙영역에 인스턴스가 생성되고 오랜기간 사용하지 않을 경우 가비지 컬렉터가 메모리를 정리한다 
   
   __※ 추가사항__  
   ```
   static 변수    ------>    클래스(멤버) 속성, 정적 변수, 정적 속성....         ---------> 스태틱 영역  
   인스턴스 변수   ------>    객체(멤버) 속성, 객체 변수 ...                     ---------> 힙 영역  
   local 변수     ------>    지역 변수                                         ---------> 스택 영역(스택 프레임 내부)  
   ```
  
    
# 3장 자바와 객체 지향
### 객체지향은 인간 지향이다
  프로그래밍 언어의 발전사를 보면 개발자를 더욱 편하고 이롭게 하기 위한 과정임을 알 수 있다.
  
  포인터같이 눈높이를 기계 수준으로 낮추지 않으면 이해하기 매우 힘든 부분이라서 인간이 이해하기 쉽게 현실 세계처럼 프로그래밍하는 방법을 찾다가
  객체 향 개념이 탄생함
  
  기존의 구조적 프로그래밍 언어에서 가장 중요하게 여긴건 "함수"였다. 함수는 코드를 논리적인 단위로 구분하고 분할해서 정복하자라는 것이다.
  
  즉 D&C하자는 것이다. (D&C는 Divide and Conquer의 머리로 분할 정복이라는 뜻이다)
  
  아무리 복잡한 문제라도 작은 문제로 분할해서 하나씩 정복하다 보면 결국 해결된다는 전략
  몇 천, 몇 만 라인의 명령어를 논리적인 단위로 나누어 블록화해서 작성하자는 것이다. 이런 논리적인 단위의 블록을 함수라고 함
  
  함수의 목적 : 논리의 분할, 중복 제거
  
  함수로 인하여 프로그래밍이 좀 더 편해지고 나서 더욱 파격적인 제안이 나온 것이 바로 객체 지향 개념이다.
  
  ### 객체지향의 4대 특성 - 캡! 상추다
  - 캡 -> 캡슐화(Encapsulation) : 정보 은닉(information hiding)
  - 상 -> 상속 ~~(Inheritance)~~ : 재사용
    - 상속의 개념 -> 조직도, 계층도 (X), 분류도 (O)  
    - 상속관계에서 반드시 만족해야 할 문장  
        -__하위 클래스는 상위 클래스다.__  
    - __하위클래스의 인스턴스가 생성될 때 상위클래스의 인스턴스도 함께 생성된다.__  
  - 추 -> 추상화(Abstraction) : 모델링
    - 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용
    - 추상화는 모델링이다.
    - __구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것__
    - 클래스 설계에서 가장 중요한 것은 __추상화__
    - 추상화를 넓게 본다면 아래의 내용도 포함된다.
      1. 상속을 통한 추상화, 구체화
      2. 인터페이스를 통한 추상화
      3. 다형성을 통한 추상화
  - 다 -> 다형성(Polymorphism) : 사용 편의  
     - 상위 클래스와 하위 클래스 사이의 다형성  
     - 인터페이스와 구현클래스의 다형성  
     - 오버로딩과 오버라이딩  

# 4장 자바가 확장한 객체지향
 - static 블록 -> 스태틱 영역에 로딩될 때 실행이지만, 실제로는 해당 패키지 또는 클래스가 처음으로 사용될 때 로딩되는 것이 맞음  
 ```java
 class A {
     static {
          System.out.println("스태틱 블록");
     }
 }
 ```
 - 인스턴스 블록 -> 인스턴스가 생성될 때마다 블록 실행, 객체 생성자가 실행되기 전에 먼저 실행
 ```java
 class A {
     {
          System.out.println("인스턴스 블록");
     }
 }
 ```
 - instanceof -> 하위클래스와 상위클래스 관계는 true 반환  
 ```java
 하위클래스 instanceof 하위클래스
 하위클래스 instanceof 상위클래스
 ```
 - this -> 똑같은 인스턴스가 여러개 있을 때 힙 영역에서 한개의 인스턴스와 스태틱 영역에 정적 인스턴스를 하나 만들어서 this 키워드를 사용하여 업무 수행..  
 - 만약 아래와 같이 100개의 인스턴스를 생성한 후 test 메소드를 실행한다면 힙영역의 낭비
 ```java
 
 class A{
    void test(){
        System.out.println("테스트");
    }
 }
 ...
 A[] a = new A[100];
 for(int i=0;i<a.length;i++){
    a[i] = new A();
 }
 for(int i=0;i<a.length;i++){
     a[i].test();
 }
 ```
 
 ```java
    // 이렇게 변경되서 사용된다고 생각하면 됨
    class A{
    static void test(A this){
        System.out.println("테스트");
    }
    ...
    A[] a = new A[100];
 for(int i=0;i<a.length;i++){
    a[i] = new A();
 }
 for(int i=0;i<a.length;i++){
     A.test(a[i]);
 }
 }
 ```
 __※ 추후에 람다와 자바8 리플렉션, 스트림 API [일급 컬렉션](https://jojoldu.tistory.com/412?category=635881)__
 
 # 5장 객체 지향 설계 원칙 SOLID  
 - SRP(Single Responsibility Principle) : 단일 책임 원칙  
    - __어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.__  
 ```java
    class 사람 {
      String 군번;
      ...
    }
    
    ...
    
    사람 로미오 = new 사람();
    사람 줄리엣 = new 사람();
    로미오.군번 = "16-72016702";
    줄리엣.군번 = "15-71241156"; // ?
    // 사람클래스를 남자와 여자로 분리시켜 남자 클래스에만 군번 속성을 부여
 ```
   - 아래는 메소드가 SRP를 지키지 못하는 경우이다.
 ```java
    class 강아지{
      final static Boolean 수컷 = true;
      final static Boolean 암컷 = false;
      Boolean 성별;
      
      void 소변보다(){
        if(this.성별 == 수컷){
          // 한쪽 다리를 들고 소변을 본다.
        } else {
          // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
      }
    }
 ```
   - 이렇게 리팩터링 해주면 된다.
 ```java
    abstract class 강아지{
        abstract void 소변보다();
    }
    
    class 수컷강아지 extends 강아지{
      @Override
      void 소변보다(){
        // 한쪽 다리를 들고 소변을 본다.
      }
    }
    
    class 암컷강아지 extends 강아지{
      @Override
      void 소변보다(){
        // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
      }
    }
 ```   
   - 분기 처리를 위한 if 문은 되도록이면 다음과 같이 단일 책임의 원칙을 지켜 클래스, 인터페이스로 분리시켜 구현하는게 좋음  
    
 - OCP(Open Close Principle) : 개방 폐쇄 원칙  
    - 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. 
    - __자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.__  
    - 대표적인 예) JDBC 인터페이스 -> 데이터베이스가 달라도 Connection을 설정하는 법만 따로 설정한다면 동일하게 기능 수행 가능  
    - __유연성, 재사용성, 유지보수성 등을 얻을 수 있으므로 객체 지향 프로그래밍에서 반드시 지켜야 할 원칙!__  
    
 - LSP(Liskov Subsitution Principle) : 리스코프 치환 원칙  
    - __서브 타입은 언제나 자신의 기반 타입(Base Type)으로 교체할 수 있어야 한다.__
    - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
    ```java
      아버지 춘향이 = new 딸();   -> X (리스코프 치환 원칙 무시)
      동물 뽀로로 = new 펭귄();   -> O (리스코프 치환 원칙 만족)
    ```  
    
 - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙  
    - __클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.__ 
    - ISP를 이야기할 때 항상 함께 등장하는 원칙 중 하나로 인터페이스 최소주의 원칙이 있다. 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것이다.  
    
 - DIP(Dependency Inversion Principle) : 의존 역전 원칙  
    - 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.  
    - 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.  
    - 자주 변경되는 구체(Concrete) 클래스에 의존하지 마라  
    - __자신보다 변하기 쉬운 것에 의존하지 마라__  
    ```java
      자동차 -------> class 스노우타이어 ( 구체화된 클래스에 의존하면 안 됨 )
      자동차 -------> interface 타이어  ( 추상회된 클래스에 의존해야 함 )
               스노우 타이어, 일반 타이어, 광폭 타이어
    ```
    
 - SOLID를 이야기할 때 빼놓을 수 없는 것이 SOC이다. SoC(Separation Of Concerns) : 관심사의 분리  
    - __관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것이다. 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어가 있어야 한다라는 것이 SoC이다.__  
    
 __※ 좋은 소프트웨어 설계를 위해서는 결합도(coupling)은 낮추고 응집도(cohesion)는 높이는 것이 바람직하다.__  
 
 
 # 6장 스프링이 사랑한 디자인 패턴    
  
 ## 1. 어댑터 패턴(Adapter Pattern)  
  
  - ODBC/JDBC가 그 예  
  - 어댑터 패턴이 적용되지 않은 예  
    
 ```java
     public class ServiceA {
        void runServiceA() {
            System.out.println("ServiceA");
        }
     }
     
     public class ServiceB {
        void runServiceB() {
            System.out.println("ServiceB");
        }
     }
     
     public class ClientWithNoAdapter {
        public static void main(String[] arg) {
            ServiceA sa1 = new ServiceA();
            ServiceB sb1 = new ServiceB();
            sa1.runServiceA();
            sb1.runServiceB();
        }
     }
 ```
  - main 메서드를 살펴보면 sa1과 sb1이 호출하는 메서드가 비슷한 일을 하지만 메서드명이 다른 것을 볼 수 있다.  밑의 코드는 어댑터 패턴을 적용시킨 예이다.
 ```java
     public class AdapterServiceA {
        ServiceA sa1 = new ServiceA();
     
        void runService() {
            sa1.runService();
        }
     } 
     
     public class AdapterServiceB {
        ServiceB sb1 = new ServiceB();
     
        void runService() {
            sb1.runService();
        }
     }
     
     public class ClientWithAdapter {
        public static void main(String[] arg) {
            AdapterServiceA sa1 = new AdapterServiceA();
            AdapterServiceB sb1 = new AdapterServiceB();
            sa1.runService();
            sb1.runService();
        }
     }
 ```  
    
  - 어댑터 패턴을 적용한다면 service()라는 동일한 메서드명으로 두 객체의 메서드를 호출하는 것을 볼 수 있다.  어댑터 패턴은 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴으로, 한 문장으로 정리한다면 다음과 같다.  
    
  - __호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴__  
  
 ## 2. 프록시 패턴(Proxy Pattern)  
  - 다음은 프록시 패턴을 사용하지 않고 직접 호출하는 예제이다.  
  ```java
    public class Service {
        public String runSomething() {
            return "서비스 짱!!!";
        }
    }
    
    public class ClientWithNoProxy() {
        public static void main(String[] args) {
            // 프록시를 이용하지 않은 호출
            Service service = new Service();
            System.out.println(service.runSomthing());
        }
    }
  ```
  - 다음은 프록시 패턴이 적용된 예이다.  프록시 패턴의 경우 실제 서비스 객체가 가진 메서드와 같은 이름의 메서드를 사용하는데, 이를 위해 인터페이스를 사용한다.  
  - 인터페이스를 사용하면 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입해 클라이언트 쪽에서는 실제 서비스 객체를 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리할 수도 있다.  
  ```java
  public interface IService {
      String runSomething();
  }
  
  public class Service implements IService {
      public String runSomething() {
          return "서비스 짱!!!";
      }
  }
  
  public class Proxy implements IService {
      IService service1;
      
      public String runSumething() {
          System.out.println("호출에 대한 흐름 제어가 주목적, 반환 결과를 그대로 전달");
          
          service1 = new Service();
          return service1.rumSomething();
      }
  }
  
  public class ClientWithProxy() {
        public static void main(String[] args) {
            // 프록시를 이용하지 않은 호출
            IService proxy = new Proxy();
            System.out.println(proxy.runSomthing());
        }
    }
  ```
  
  - 프록시 패턴의 중요 포인트  
  ```
      - 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
      - 대리자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
      - 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
      - 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.
  ```
  - 여기서 대리자/대변인이라는 이름에 주목해 보면 대변인은 해당 기관의 입장을 대변할 뿐 그 입장에 자신의 입장을 가감하지 않는다. 그런거처럼 프록시 패턴도 실제 서비스의 메서드의 반환값에 가감하는 것을 목적으로 하지 않고 제어의 흐름을 변경하거나 다른 로직을 수행하기 위해 사용한다.  
  - __제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴__  
  - OCP와 DIP를 잘 활용한 패턴이다.  
  
 ## 3. 데코레이터 패턴(Decorator Pattern)  
  - 원본에 장식을 더하는 패턴, 프록시 패턴과 구현 방법이 같다. 다만 프록시 패턴은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달하는 반면 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 덧입힌다.  
  ```
  프록시 패턴     --> 제어의 흐름을 변경하거나, 별도의 로직 처리를 목적으로 한다.
                     클라이언트가 받는 반환값을 특별한 경우가 아니면 변경하지 않는다.
  데코레이터 패턴 --> 클라이언트가 받는 반환값에 장식을 더한다.
  ```  
  
  ```java
    public interface IService {
        public abstract String runSomething();
    }
    
    public class Service implements IService {
        public String rumSomething() {
            return "서비스 짱!!!";
        }
    }
  
    public class Decorator implements IService {
        IService service;
        
        public String runSomething() {
            System.out.println("호출에 대한 장식이 주목적, 클라이언트에게 반환 결과에 장식을 더하여 전달");
            service = new Service();
            return "정말" + service.rumSomething();
        }
    }
    
    public class ClientWithDecorator {
        public static void main(String[] args) {
            IService decorator = new Decorator();
            System.out.println(decorator.runSomething());
        }
    }
  ```  
  
  - 데코레이터 패턴의 중요 포인트
  ```
    - 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
    - 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
    - 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
    - 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.
  ```  
  - __메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴__  
  
 ## 4. 싱글턴 패턴(Singleton Pattern)  
  - __싱글턴 패턴이란 인스턴스를 하나만 만들어 사용하기 위한 패턴__
  - 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되서 예상치 못한 결과를 낳을 수 있음  
  - 그래서 인스턴스를 하나만 만들어서 그것을 계속해서 재사용하는 패턴이 싱글톤 패턴  
 
 ```java
public class Singleton {
    static Singleton singletonObject; // 정적 참조 변수
    private Singleton() {}; // private 생성자
    
    // 객체 반환 정적 메서드
    public static Singleton getInstance(){
        if(singletonObject == null){
            singletonObject = new Singleton();
        }
        return singletonObject;
    }
}
 ```
  - private 생성자가 있으므로 외부에서 객체 생성을 할 수 없고 지정된 객체 반환 정적 메서드를 이용해서만 객체를 생성하므로 하나의 객체를 계속 사용할 수 있다.
  - 싱글턴 패턴의 특징
  ```
  - private 생성자를 갖는다.
  - 단일 객체 참조 변수를 정적 속성으로 갖는다.
  - 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.
  - 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.
  ```
  
 ## 5. 템플릿 메서드 패턴(Template Method Pattern)  
  - __상위클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴__  
  
  
